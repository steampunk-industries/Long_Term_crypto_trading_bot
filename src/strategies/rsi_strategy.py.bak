from typing import Dict, List, Optional, Union, Tuple
import pandas as pd
import numpy as np
from loguru import logger
import ta  # Technical Analysis library

from src.exchanges.base_exchange import BaseExchange
from src.strategies.base_strategy import BaseStrategy

class RSIStrategy(BaseStrategy):
    """
    Relative Strength Index (RSI) strategy.

    This strategy generates buy signals when the RSI is below the oversold threshold,
    and sell signals when the RSI is above the overbought threshold.
    """

    def __init__(
        self,
        exchange: BaseExchange,
        symbol: str = "BTC/USDT",
        timeframe: str = "1h",
        risk_level: str = "medium",
        rsi_period: int = 14,
        oversold_threshold: float = 30.0,
        overbought_threshold: float = 70.0,
        **kwargs
    ):
        """
        Initialize the RSI strategy.

        Args:
            exchange: Exchange instance to use for trading
            symbol: Trading pair symbol (e.g., 'BTC/USDT')
            timeframe: Timeframe for analysis (e.g., '1m', '5m', '1h', '1d')
            risk_level: Risk level ('low', 'medium', 'high')
            rsi_period: Period for the RSI calculation
            oversold_threshold: RSI threshold for oversold conditions
            overbought_threshold: RSI threshold for overbought conditions
            **kwargs: Additional parameters to pass to the parent class
        """
        super().__init__(exchange, symbol, timeframe, risk_level, **kwargs)

        # Use more aggressive thresholds by default for more trading opportunities
        self.rsi_period = rsi_period
        self.oversold_threshold = 40.0 if oversold_threshold == 30.0 else oversold_threshold
        self.overbought_threshold = 60.0 if overbought_threshold == 70.0 else overbought_threshold

        logger.info(f"Initialized RSIStrategy with rsi_period={rsi_period}, oversold={self.oversold_threshold}, overbought={self.overbought_threshold}")

    def _calculate_rsi(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate RSI for the data.

        Args:
            data: DataFrame with OHLCV data

        Returns:
            pd.DataFrame: DataFrame with RSI added
        """
        # Calculate RSI using the ta library
        data['rsi'] = ta.momentum.RSIIndicator(data['close'], window=self.rsi_period).rsi()

        return data

    def generate_signals(self, data: pd.DataFrame) -> Tuple[str, float, Dict]:
        """
        Generate trading signals based on RSI values.

        Args:
            data: DataFrame with OHLCV data

        Returns:
            Tuple[str, float, Dict]: Signal type ('buy', 'sell', 'hold'), confidence level, and metadata
        """
        # Calculate RSI
        data = self._calculate_rsi(data)

        # Drop NaN values
        data = data.dropna()

        if len(data) < 2:
            return 'hold', 0.0, {'reason': 'Insufficient data'}

        # Get the last two rows
        current = data.iloc[-1]
        previous = data.iloc[-2]

        # Check RSI conditions
        if current['rsi'] < self.oversold_threshold:
            # Oversold condition (RSI below threshold)
            signal_type = 'buy'
            # Calculate confidence based on how far below the threshold
            confidence = min(1.0, (self.oversold_threshold - current['rsi']) / self.oversold_threshold)
            metadata = {
                'reason': 'Oversold condition',
                'rsi': current['rsi'],
                'threshold': self.oversold_threshold,
                'close': current['close'],
                'stop_loss': current['close'] * (1 - self.stop_loss_pct),  # Add stop loss
                'take_profit': current['close'] * (1 + self.take_profit_pct)  # Add take profit
            }
        elif current['rsi'] > self.overbought_threshold:
            # Overbought condition (RSI above threshold)
            signal_type = 'sell'
            # Calculate confidence based on how far above the threshold
            confidence = min(1.0, (current['rsi'] - self.overbought_threshold) / (100 - self.overbought_threshold))
            metadata = {
                'reason': 'Overbought condition',
                'rsi': current['rsi'],
                'threshold': self.overbought_threshold,
                'close': current['close']
            }
        else:
            # RSI in neutral zone
            signal_type = 'hold'
            # Calculate confidence based on distance from thresholds
            distance_to_oversold = current['rsi'] - self.oversold_threshold
            distance_to_overbought = self.overbought_threshold - current['rsi']

            if distance_to_oversold < distance_to_overbought:
                # Closer to oversold
                confidence = 0.5 * (1 - distance_to_oversold / (self.overbought_threshold - self.oversold_threshold))
                metadata = {
                    'reason': 'Approaching oversold',
                    'rsi': current['rsi'],
                    'threshold': self.oversold_threshold,
                    'close': current['close']
                }
            else:
                # Closer to overbought
                confidence = 0.5 * (1 - distance_to_overbought / (self.overbought_threshold - self.oversold_threshold))
                metadata = {
                    'reason': 'Approaching overbought',
                    'rsi': current['rsi'],
                    'threshold': self.overbought_threshold,
                    'close': current['close']
                }

        return signal_type, confidence, metadata

    def run(self) -> Optional[Tuple[str, Dict]]:
        """
        Run the strategy once.

        This method:
        1. Gets historical data for the symbol
        2. Generates signals based on RSI values
        3. Executes the signal if strong enough
        4. Applies risk management controls

        Returns:
            Optional[Tuple[str, Dict]]: Signal type and trade details if executed, None otherwise
        """
        try:
            # Get historical data
            data = self.get_historical_data()

            if data.empty:
                logger.warning(f"No historical data available for {self.symbol}")
                return None

            # Generate signals
            signal_type, confidence, metadata = self.generate_signals(data)

            # Apply risk management controls
            if signal_type == 'buy':
                # Apply stop loss and take profit
                metadata['stop_loss'] = float(data.iloc[-1]['close']) * (1 - self.stop_loss_pct)
                metadata['take_profit'] = float(data.iloc[-1]['close']) * (1 + self.take_profit_pct)
                
                # Apply position sizing based on risk
                current_price = float(data.iloc[-1]['close'])
                max_position_value = self.exchange.get_balance(self.symbol.split('/')[1]) * self.max_position_size
                
                # Calculate potential loss per unit
                potential_loss_per_unit = current_price - metadata['stop_loss']
                
                # Calculate position size based on risk management
                if potential_loss_per_unit > 0:
                    max_risk_amount = max_position_value * 0.02  # Risk at most 2% of position value
                    position_size = max_risk_amount / potential_loss_per_unit
                    metadata['position_size'] = position_size
                    logger.info(f"Position size calculated based on risk: {position_size} units")
                else:
                    # Fallback to default position sizing if stop loss is not below current price
                    position_size = self.calculate_position_size(current_price)
                    metadata['position_size'] = position_size
                    logger.warning(f"Using default position sizing: {position_size} units (potential_loss_per_unit <= 0)")

            # Execute the signal if confidence is high enough (lowered threshold for more active trading)
            if confidence > 0.4:  # Execute moderate to high-confidence signals
                result = self.execute_signal(signal_type, confidence, metadata)
                if result:
                    logger.info(f"Successfully executed {signal_type} signal with confidence {confidence}")
                    return signal_type, metadata
                else:
                    logger.warning(f"Failed to execute {signal_type} signal with confidence {confidence}")
            else:
                logger.info(f"Signal {signal_type} not executed due to low confidence: {confidence}")
                # Log the signal anyway for tracking
                self._log_signal(signal_type, confidence, None, metadata)

            return None
            
        except Exception as e:
            logger.error(f"Error running RSI strategy: {e}")
            return None
